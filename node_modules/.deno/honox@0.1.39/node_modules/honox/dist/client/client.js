import { render, createElement as createElementHono } from "hono/jsx/dom";
import {
  COMPONENT_EXPORT,
  COMPONENT_NAME,
  DATA_HONO_TEMPLATE,
  DATA_SERIALIZED_PROPS
} from "../constants.js";
const createClient = async (options) => {
  const FILES = options?.ISLAND_FILES ?? {
    ...import.meta.glob("/app/islands/**/[a-zA-Z0-9-]+.tsx"),
    ...import.meta.glob("/app/**/_[a-zA-Z0-9-]+.island.tsx"),
    ...import.meta.glob("/app/**/$[a-zA-Z0-9-]+.tsx")
  };
  const hydrateComponent = async (document2) => {
    const filePromises = Object.keys(FILES).map(async (filePath) => {
      const componentName = filePath;
      const elements = document2.querySelectorAll(
        `[${COMPONENT_NAME}="${componentName}"]:not([data-hono-hydrated])`
      );
      if (elements) {
        const elementPromises = Array.from(elements).map(async (element) => {
          element.setAttribute("data-hono-hydrated", "true");
          const exportName = element.getAttribute(COMPONENT_EXPORT) || "default";
          const fileCallback = FILES[filePath];
          const file = await fileCallback();
          const Component = await file[exportName];
          const serializedProps = element.attributes.getNamedItem(DATA_SERIALIZED_PROPS)?.value;
          const props = JSON.parse(serializedProps ?? "{}");
          const hydrate = options?.hydrate ?? render;
          const createElement = options?.createElement ?? createElementHono;
          let maybeTemplate = element.childNodes[element.childNodes.length - 1];
          while (maybeTemplate?.nodeName === "TEMPLATE") {
            const propKey = maybeTemplate.getAttribute(DATA_HONO_TEMPLATE);
            if (propKey == null) {
              break;
            }
            let createChildren = options?.createChildren;
            if (!createChildren) {
              const { buildCreateChildrenFn } = await import("./runtime");
              createChildren = buildCreateChildrenFn(
                createElement,
                async (name) => (await FILES[`${name}`]()).default
              );
            }
            props[propKey] = await createChildren(
              maybeTemplate.content.childNodes
            );
            maybeTemplate = maybeTemplate.previousSibling;
          }
          const newElem = await createElement(Component, props);
          await hydrate(newElem, element);
        });
        await Promise.all(elementPromises);
      }
    });
    await Promise.all(filePromises);
  };
  const triggerHydration = options?.triggerHydration ?? (async (hydrateComponent2) => {
    if (document.querySelector('template[id^="H:"], template[id^="E:"]')) {
      const { hydrateComponentHonoSuspense } = await import("./runtime");
      await hydrateComponentHonoSuspense(hydrateComponent2);
    }
    await hydrateComponent2(document);
  });
  await triggerHydration?.(hydrateComponent);
};
export {
  createClient
};
