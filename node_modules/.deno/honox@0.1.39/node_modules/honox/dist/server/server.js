import { Hono } from "hono";
import { createMiddleware } from "hono/factory";
import { IMPORTING_ISLANDS_ID } from "../constants.js";
import { contextStorage } from "./context-storage.js";
import {
  filePathToPath,
  groupByDirectory,
  listByDirectory,
  sortDirectoriesByDepth
} from "./utils/file.js";
const NOTFOUND_FILENAME = "_404.tsx";
const ERROR_FILENAME = "_error.tsx";
const METHODS = ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"];
const createApp = (options) => {
  const root = options.root;
  const rootRegExp = new RegExp(`^${root}`);
  const getRootPath = (dir) => filePathToPath(dir.replace(rootRegExp, ""));
  const app = options.app ?? new Hono();
  const trailingSlash = options.trailingSlash ?? false;
  app.use(async function ShareContext(c, next) {
    await contextStorage.run(c, () => next());
  });
  if (options.init) {
    options.init(app);
  }
  const NOT_FOUND_FILE = options.NOT_FOUND;
  const notFoundMap = groupByDirectory(NOT_FOUND_FILE);
  const ERROR_FILE = options.ERROR;
  const errorMap = groupByDirectory(ERROR_FILE);
  const RENDERER_FILE = options.RENDERER;
  const rendererList = listByDirectory(RENDERER_FILE);
  const MIDDLEWARE_FILE = options.MIDDLEWARE;
  const ROUTES_FILE = options.ROUTES;
  const routesMap = sortDirectoriesByDepth(groupByDirectory(ROUTES_FILE));
  const getPaths = (currentDirectory, fileList) => {
    let paths = fileList[currentDirectory] ?? [];
    const getChildPaths = (childDirectories) => {
      paths = fileList[childDirectories.join("/")];
      if (!paths) {
        childDirectories.pop();
        if (childDirectories.length) {
          getChildPaths(childDirectories);
        }
      }
      return paths ?? [];
    };
    const renderDirPaths = currentDirectory.split("/");
    paths = getChildPaths(renderDirPaths);
    paths.sort((a, b) => a.split("/").length - b.split("/").length);
    return paths;
  };
  const errorHandlerMap = {};
  for (const map of routesMap) {
    for (const [dir, content] of Object.entries(map)) {
      const subApp = new Hono();
      let hasIslandComponent = false;
      const notFoundHandler = getNotFoundHandler(dir, notFoundMap);
      if (notFoundHandler) {
        subApp.use(async (c, next) => {
          await next();
          if (c.res.status === 404) {
            const notFoundResponse = await notFoundHandler(c);
            const res = new Response(notFoundResponse.body, {
              status: 404,
              headers: notFoundResponse.headers
            });
            c.res = res;
          }
        });
      }
      const rendererPaths = getPaths(dir, rendererList);
      rendererPaths.map((path) => {
        const renderer = RENDERER_FILE[path];
        const importingIslands = renderer[IMPORTING_ISLANDS_ID];
        if (importingIslands) {
          hasIslandComponent = true;
        }
        const rendererDefault = renderer.default;
        if (rendererDefault) {
          subApp.all("*", rendererDefault);
        }
      });
      const middlewareFile = Object.keys(MIDDLEWARE_FILE).find((x) => {
        const replacedDir = dir.replaceAll("[", "\\[").replace("]", "\\]");
        return new RegExp(replacedDir + "/_middleware.tsx?").test(x);
      });
      if (middlewareFile) {
        const middleware = MIDDLEWARE_FILE[middlewareFile];
        if (middleware.default) {
          subApp.use(...middleware.default);
        }
      }
      for (const [filename, route] of Object.entries(content)) {
        const importingIslands = route[IMPORTING_ISLANDS_ID];
        const setInnerMeta = createMiddleware(async function innerMeta(c, next) {
          c.set(IMPORTING_ISLANDS_ID, importingIslands ? true : hasIslandComponent);
          await next();
        });
        const routeDefault = route.default;
        const path = filePathToPath(filename);
        if (routeDefault && "fetch" in routeDefault) {
          subApp.use(setInnerMeta);
          subApp.route(path, routeDefault);
        }
        for (const m of METHODS) {
          const handlers = route[m];
          if (handlers) {
            subApp.on(m, path, setInnerMeta);
            subApp.on(m, path, ...handlers);
          }
        }
        if (routeDefault && Array.isArray(routeDefault)) {
          subApp.get(path, setInnerMeta);
          subApp.get(path, ...routeDefault);
        }
        if (typeof routeDefault === "function") {
          subApp.get(path, setInnerMeta);
          subApp.get(path, async (c) => {
            const result = await routeDefault(c);
            if (result instanceof Response) {
              return result;
            }
            return c.render(result, route);
          });
        }
      }
      const errorHandler = getErrorHandler(dir, errorMap);
      if (errorHandler) {
        errorHandlerMap[dir] = errorHandler;
      }
      for (const [path, errorHandler2] of Object.entries(errorHandlerMap)) {
        const regExp = new RegExp(`^${path}`);
        if (regExp.test(dir) && errorHandler2) {
          subApp.onError(errorHandler2);
        }
      }
      let rootPath = getRootPath(dir);
      if (trailingSlash) {
        rootPath = /\/$/.test(rootPath) ? rootPath : rootPath + "/";
      }
      app.route(rootPath, subApp);
    }
  }
  for (const map of routesMap.reverse()) {
    const dir = Object.entries(map)[0][0];
    const subApp = new Hono();
    applyNotFound(subApp, dir, notFoundMap);
    const rootPath = getRootPath(dir);
    app.route(rootPath, subApp);
  }
  return app;
};
function getNotFoundHandler(dir, map) {
  for (const [mapDir, content] of Object.entries(map)) {
    if (dir === mapDir) {
      const notFound = content[NOTFOUND_FILENAME];
      if (notFound) {
        return notFound.default;
      }
    }
  }
}
function applyNotFound(app, dir, map) {
  for (const [mapDir, content] of Object.entries(map)) {
    if (dir === mapDir) {
      const notFound = content[NOTFOUND_FILENAME];
      if (notFound) {
        const notFoundHandler = notFound.default;
        const importingIslands = notFound[IMPORTING_ISLANDS_ID];
        if (importingIslands) {
          app.use("*", (c, next) => {
            c.set(IMPORTING_ISLANDS_ID, true);
            return next();
          });
        }
        app.get("*", (c) => {
          c.status(404);
          return notFoundHandler(c);
        });
      }
    }
  }
}
function getErrorHandler(dir, map) {
  for (const [mapDir, content] of Object.entries(map)) {
    if (dir === mapDir) {
      const errorFile = content[ERROR_FILENAME];
      if (errorFile) {
        const matchedErrorHandler = errorFile.default;
        if (matchedErrorHandler) {
          const errorHandler = async (error, c) => {
            const importingIslands = errorFile[IMPORTING_ISLANDS_ID];
            if (importingIslands) {
              c.set(IMPORTING_ISLANDS_ID, importingIslands);
            }
            c.status(500);
            return matchedErrorHandler(error, c);
          };
          return errorHandler;
        }
      }
    }
  }
}
export {
  createApp
};
