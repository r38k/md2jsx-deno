import path, { resolve } from "path";
import { existsSync, mkdirSync, writeFileSync } from "fs";
const defaultOptions = {
  hostname: "localhost:5173",
  exclude: [],
  frequency: {},
  priority: {},
  outputFileName: "sitemap.xml",
  routesDir: "/app/routes"
};
const tsFiles = [];
function sitemap(options) {
  validateOptions(options);
  const hostname = options?.hostname ?? defaultOptions.hostname ?? "localhost:5173";
  const exclude = options?.exclude ?? defaultOptions.exclude ?? [];
  const frequency = options?.frequency ?? defaultOptions.frequency ?? {};
  const priority = options?.priority ?? defaultOptions.priority ?? {};
  const outputFileName = options?.outputFileName ?? defaultOptions.outputFileName ?? "sitemap.xml";
  const routesDir = options?.routesDir ?? defaultOptions.routesDir ?? "/app/routes";
  return {
    name: "vite-plugin-hono-sitemap",
    apply: "build",
    transform(_code, id) {
      if (isFilePathMatch(id, exclude)) {
        tsFiles.push(id);
      }
      return { code: _code, map: null };
    },
    buildEnd() {
      const routes = processRoutes(tsFiles, hostname, routesDir, frequency, priority);
      const sitemap2 = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${routes.map(
        (page) => `
  <url>
    <loc>${page.url}/</loc>
    <lastmod>${page.lastMod}</lastmod>
    <changefreq>${page.changeFreq}</changefreq>
    <priority>${page.priority}</priority>
  </url>
`
      ).join("")}
</urlset>`;
      try {
        const distPath = path.resolve(process.cwd(), "dist");
        if (!existsSync(distPath)) {
          mkdirSync(distPath, { recursive: true });
        }
        writeFileSync(resolve(process.cwd(), "dist", outputFileName), sitemap2);
        console.info(`Sitemap generated successfully: ${outputFileName}`);
      } catch (error) {
        console.error(`Failed to write sitemap file: ${error}`);
        throw new Error(`Sitemap generation failed: ${error}`);
      }
    }
  };
}
function isFilePathMatch(filePath, exclude) {
  const patterns = [
    ".*/app/routes/(?!.*(_|\\$|\\.test|\\.spec))[^/]+\\.(tsx|md|mdx)$",
    ".*/app/routes/.+/(?!.*(_|\\$|\\.test|\\.spec))[^/]+\\.(tsx|md|mdx)$",
    ".*/app/routes/\\.well-known/(?!.*(_|\\$|\\.test|\\.spec))[^/]+\\.(tsx|md|mdx)$"
  ];
  const normalizedPath = path.normalize(filePath).replace(/\\/g, "/");
  if (exclude.some((excludePath) => normalizedPath.includes(excludePath))) {
    return false;
  }
  for (const pattern of patterns) {
    const regex = new RegExp(`^${pattern}$`);
    if (regex.test(normalizedPath)) {
      return true;
    }
  }
  return false;
}
function validateOptions(options) {
  if (options === void 0) {
    return;
  }
  if (options.hostname && !/^(http:\/\/|https:\/\/)/.test(options.hostname)) {
    throw new Error("hostname must start with http:// or https://");
  }
  if (options.priority) {
    for (const [key, value] of Object.entries(options.priority)) {
      const priority = Number.parseFloat(value);
      if (Number.isNaN(priority) || priority < 0 || priority > 1) {
        throw new Error(`Invalid priority value for ${key}: ${value}. Must be between 0.0 and 1.0`);
      }
    }
  }
  if (options.frequency) {
    const validFrequencies = [
      "always",
      "hourly",
      "daily",
      "weekly",
      "monthly",
      "yearly",
      "never"
    ];
    for (const [key, value] of Object.entries(options.frequency)) {
      if (!validFrequencies.includes(value)) {
        throw new Error(`Invalid frequency value for ${key}: ${value}`);
      }
    }
  }
}
function processRoutes(files, hostname, routesDir, frequency, priority) {
  const modifiedHostname = hostname.endsWith("/") ? hostname.slice(0, -1) : hostname;
  return files.map((file) => {
    const route = file.substring(file.indexOf(routesDir) + routesDir.length);
    const withoutExtension = route.replace(/\.(tsx|mdx)$/, "");
    const url = withoutExtension === "/index" ? modifiedHostname : `${modifiedHostname}${withoutExtension}`;
    return {
      url,
      lastMod: (/* @__PURE__ */ new Date()).toISOString(),
      changeFreq: getFrequency(withoutExtension, frequency),
      priority: getPriority(withoutExtension, priority)
    };
  });
}
function getFrequency(url, frequency) {
  return getValueForUrl(url, frequency, "weekly");
}
function getPriority(url, priority) {
  return getValueForUrl(url, priority, "0.5");
}
function getValueForUrl(url, patterns, defaultValue) {
  const urlWithoutIndex = url.replace(/\/index$/, "/");
  const sortedPatterns = Object.entries(patterns).sort((a, b) => b[0].length - a[0].length);
  for (const [pattern, value] of sortedPatterns) {
    if (new RegExp(`^${pattern.replace(/\*/g, ".*")}$`).test(urlWithoutIndex)) {
      return value;
    }
  }
  return defaultValue;
}
var sitemap_default = sitemap;
export {
  sitemap_default as default,
  defaultOptions,
  getFrequency,
  getPriority,
  getValueForUrl,
  isFilePathMatch,
  processRoutes,
  sitemap,
  validateOptions
};
